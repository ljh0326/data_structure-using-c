 * Practice Data_Structure Using C
 * 자료구조 복습
 * http://blog.naver.com/ljh0326s
 * 
=========================================================================
 * 2017-07-23 
 * 
 * linked-list.c
 * 
 * 알게된 점!!!!! 
 * strdup 문자열 받아서 주소값 반환
 * 헤드포인터는 항상 첫째노드 가리키고 있어야함 그래서 조회할때 새로운 포인터 생성
 * 노드를 삭제하기위해서는 그 전 노드를 알아야 한다. 그래서 새로운 노드를 만들어 따라가게 한다.
 *
=========================================================================
 *
 * 2017-07-24
 * 연결리스트 응용 다항식 
 * polynomial.c
 * 
 * 가정 
 * 1. 다항식의 이름은 x를 제외한 영문 소문자
 * 2. 변수는 항상 x이다.
 * 3. 각 항의 지수는 음이 아닌 정수이고, 계수는 정수이다.
 * 4. 항들이 반드시 차수에 대해 내림차순으로 입력되는 것은 아니며, 동일 차수의 항이 여럿 있을 수도 있다.
 * 5. =, +, - 등의 앞 뒤로 하나 이상의 공백이 있을수도, 없을 수도 있다.
 * 6. 함수는 항상 차수에 대한 내림차순으로 정렬되어 저장되고 출력된다.
 * 7. 동일 이름의 함수를 새로 정의할 수도있다. 이 경우 기존의 함수는 지워진다.
 * 
 * 알게된 점!!!
 * 동적으로 생성된 객체는 초기화가 필요하며 초기화 해주는 함수를 따로 만들어 사용하는 것도 좋은 방법이다.
 * 
 * 아직진행중
 * 
=========================================================================
 * 2017-07-25
 * 연결리스트 응용 다항식 - 완성 디버깅필요
 * 
 * 이중연결리스트
 * 이중연결리스트는 tail필요 -> 마지막 노드 가리킴
 * tail없어도 되지만 그럴꺼면 이중리스트 왜씀? 이중연결리스트를 쓰는 이유 중 하나는 뒤에서부터 앞으로도 갈려고하는 것
 * 
 * 노드 삽입
 * 1. 뉴노드 생성
 * 2. 뉴노드의 next = p
 * 3. 뉴노드의 prev = p -> prev
 * 3. p -> prev -> next = new_node;
 * 4. p -> prev = new_node
 * 
 * 노드 삭제
 * 1. p -> prev -> next = p -> next
 * 2. p -> next -> prev = p -> prev
 * 
 * ---------------------------------------------
 * 시간복잡도와 점근적 분석
 * 
 * 알게된 것!
 * 
 * 좋은 프로그램은?
 * 1.빠른거, 잘 구조화되어있고, 모듈화되어있어서 개선 기능 추가 재사용하기 용이한가, 호완성, 디자인
 * 2. 알고리즘의 자원 사용량 분석(객관적)
 *   2-1. 자원의 종류 : 시간, 메모리, 저장장치, 통신(패킷)
 * 여기서는 실행시간 분석에 대해서만 다룬다.
 
 
 *시간분석?
 *사실 실행 속도는 실행환격에 따라 달라지기 때문에 시간복잡도가 1초다 이런식으로 얘기할 수 없다.
 *그래서 일반적으로 연산의 실행 횟수를 카운트하는 것으로 시간복잡도를 측정한다. 항상이런건 아님
 *그런데 생각해보면 데이터에 따라 비교연산 횟수 달라짐 그래서 입력 데이터의 크기에 대한 함수로 표현한다.
 *그런데 데이터가 같더라도 실제 데이터에 따라 달라질 수 있음(입력 데이터가 같다고 실제 연산이 같지는 않다.)
 *그럼? 다다르다면 그냥 대표값을 이용해서 표현하는게 방법중 하나가 될 것
 *가장 대표적인 대표값 = 평균 
 *그리고 또다른 대표값이 최악의 경우( 다다른데 최악은뭐냐, 탐색에서 데이터가 마지막에 있거나 없는경우) 그럼n번 비교해야지.
 *그런데 평균시간복잡도 분석 어려움 그래서 보통은 최악의 경우 시간복잡도 사용한다.

 * 점근적 분석
 * 실행횟수 카운트할때 정확하게 분석하는게아니라 n*(n-1) + 5 가있다면 n에관한 2차함수기때문에
 * O(n^2)라고 표시함 즉 연산의 최고차항만 남기는거야 보통 빅O라고 읽기도함
 
=========================================================================
  *2017-07-26
  *순환(Recursion)
  *Recursion.java
  *자기 자신을 호출하는 함수 
  *적절한 구조를 갖춰야 무한루프에 빠지지 않는다.
  *
  * 구조의 조건 
  *   1.적어도 하나의 recursion에 빠지지 않는 조건이 존재해야한다.(Bace case라고 부른다.)
  *   2.Recursive case를 통해 반복하다보면 base case에 수렴하게 해야 한다.
  * 
  * 해석 예제
  * public static int func(int n){
      n == 0 ? return 0 : return n + func(n-1);
  }
  * 이 함수의 mission은 0~m까지의 합을 구하는 것이다.
  * n = 0 dlaus gkqdms 0 dlek.
  * n이 0보다 크다면 0에서 n까지의 합은 0에서 n-1까지 합에 n을 더한것이다.
  * 
  ----------------------------------------

  * 순환적으로 사고하기(Recursion Tginking)
  * 반복문으로 해결할수 있는 문제들을 Recursion으로 풀어보자
  * Recursion2.java
  *
1. 문자열 길이계산 길이하나하나 세는게 정석
  *     Recursive로 생각하면 문자열의 길이는 첫번째를 제외한 문자열의 길이 + 1
  * 2. 문자열의 프린트
  *     첫번째 문자를 출력한 후 Recursive로 첫번째 문자를 제외하고 출력한다.
  * 3. 문자열 뒤집어서 프린트
  *     Recursive로 첫번째 글자를 제외하고 프린트 후 첫번째 문자를 출력한다.
  * 4. 배열에있는 숫자 더하기
  *     Recursive로 마지막 데이터 전까지 모두 더한 후 마지막 문자를 더해준다.
  * 5. 파일출력
  *     Recursive로 마지막 데이터 전까지 모두 출력한 후 마지막 문자를 출력한다.
  *     
  * 모든 순환한수는 반복문으로 변경가능하며 그 역도 성립한다.
  * 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 하지만
  * 함수 호출에 따른 오버해드가 있다.
  * 
=========================================================================
  *2017-07-27
  *순환(Recursion)3
  *Designing Recursion 순환 설계 하는 방법 및 노하우
  
  *1. 구조가 복잡할수록 기본을 잊지말자
      1-1 적어도 하나의 base case, 즉 순횐되지 않고 종료되는 case가 있어야하고 모든
          case는 결국 base case로 수렴해야 한다.
  
  *2. Recursion으로 프로그래밍 할 때에는 암시적 매개변수를 명시적으로 바꿔주어야 한다.]
      ex) 순차탐색, 첫번째값이 내가 찾는거라면 즉시 반환 아니라면 나머지 타켓을 검색하면된다.
=========================================================================
 *2017-07-28
 *순환 (Recursion)응용 미로탈출
    Maze.java
 *미로찾기 문제를 해결하는 방법은 많으나 순환으로 해결하는게 가장 명확하다.
 *How? Recursive
    - 현제 내가 위치에서 출구까지 가는 경로가 있으려면
    - 1. 현재 위치가 출구거나
    - 2이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있꺼나
 *일단 Decision problem 문제로 생각해보자
    큰틀
    - 출구면 return true 
    - 출구가 아니고 주위 각 셀(최대4개)이 통로라면 다시 findPath 만약 출구를 찾으면 true 아니면false
 *
    세부내용
    - 내가 방문한 부분과 아닌 부분을 기억해야함 즉 위 큰틀에서 마크를 먼저하고 큰 틀내용을 진행하면 된다.
  
 * 응용2 Counting cells in a Block
 * 문제 : 바이너리 이미지가 주어지면 각 셀이 픽셀에 해당되고 각각 픽셀은 
 * 백그라운드 픽셀이거나 이미지 픽셀(흑백사진) blob는 서로 연결된 이미지 집합
 * 상하좌우 및 대각방향으로도 연결된 것으로 간주
 * 
 *Recursion Thinking
 *현재 픽셀이 속한 blob를 카운트하려면
    1.현재 픽셀이 image픽셀이 아니라면 0 반환
    2.현재 픽셀이 image픽셀이라면 현재픽셀을 카운트한 후
    3.중복 카운트 방지를 위해 다른 색으로 칠하고
    4.현재 픽셀에 이웃한 모든 픽셀들에 대하여 그 픽셀이 속한 blob의 크기를  카운트하여 더해준다. return counter
  
 *응용3 N-queen
   다시공부
-----------------------------------------------------------------
  *트리(Tree)
  *기본용어 노드 레벨, 자식 부모 자손 조상
  *노드가N개인 트리는 항상 N-1개의 링크를 가진다.

  * 이진트리
  * 각각의 노드는 최대 2개의 자식을 갖는다.
  * 자식 노드는 자신의 부모의 왼쪽 자식이지 오른쪽 자식인지가 지정되며 오른쪽 왼쪽이 다르면 서로 다른 노드이다.
  * 이진트리 응용 예 :Expression Tree ,허프만 코드(파일 압축)
  * FUll binary tree 모든 노드가 꽉찬 트리 , complete binary tree 노드가 몇개 비어있지만 왼쪽부터 비어있는 트리
  * full binary tree인 경우 높이가 h면 tree는 2^h-1개의 노드를 갖는다
  * 노드가 N개인 이진트리의 높이는 최악의 경우 N이 된다. 
  * 
  *이진트리 순회(traversal)
  *이진트리 모든 노드 방문 연결리스트는 순서대로 방문하면됨
  *트리는 선형적 구조가아니라 연결리스트 모든 노드 방문할때 다양한 방문이 있을 수 있음
     1. 중순위(inorder)순회
        -먼저 트리부분을 3부분으로 나눠서 생각 가장먼저 루트, 왼쪽 오른쪽 이렇게 
        -왼쪽을 inorder로 순회하고, r을 순회하고, 오른쪽을 inorder로 순회하는데 이말은 recursive함을 얘기한다.
     2. 선순위(preorder)순회
         -노드를 먼저 출력 후 외쪽 트리 오른쪽 트리 출력
     3. 후순위(postorder)tnsghl
         -왼쪽트리 출력 오른쪽 트리 출력 노드 출력 순서
     4. 그외 레벨오더(level-order) 순회
         -레벨 순서대로 출력, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 출력
         -큐를 이용하여 구현
  * 중순위 선순위 후순위는 아주 유사하다 
  * 
  ----------------------------------------------------------
  * 이진검색 트리
  * 검색트리? 트리는 계층구조를 표현하지만, 검색트리는 일종의 그냥 컨테이너 즉 일종의 집합
  * Dynamic Set이라고도 부르는데 여러게의 데이터가 다이나믹하다는 의미다.(데이터가 고정된것이아니라 추가되거나 삭제될 수도있다)
  * 키에대해 새로운 키를 추가하거나 삭제하거나 탐색하거나 하는 3가지 연산을 효율적으로 지원하기 위한 자료구조
  * 
  * 정렬된 혹은 정렬되지 않은 배열 혹은 연결리스트를 사용할 경우INSERT, SEARCH, DELETE중 하나는 O(N)이걸 해결하고자함
  * 해결 하는 방법중 하나가 트리, 그리고 다른방법이 해쉬테이블이다.
  * 
  * 이진검색트리(BST Binary Search Tree)에 대해 살펴보자
  *  1. 이진트리 각각노드가 2개씩이고 누가 왼쪽자식이고 오른쪽자식인지 명시되어있다.
  *  2. 각노드마다 하나의 데이터가 저장
  *  3. 각노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고 오른쪽 부트리에 있는 값은 크거나 같다.
  *  4. 트리의 모양에 특정 제약이없고 바이너리 트리기만 하면 된다. 
  *  
  *  Search 특정한 값 있는지 없는지 위치 찾는거 
  *  
  --------------------------------------------------------------
  *이진검색트리 최솟값 찾기
  * 알고리즘 left[x] 가 널이 될때까지 왼쪽으로 따라 내려가라 시간복잡도 O(h)
  * 
  * Successor (다음값)
  * 나보다 크면서 가장 작은 값 (모든키들이 서로 다르ㄱ다고 가정 15의 석세서는 16)
  * 석세서 구하는 방법 3가지경우
  * 1. 노드x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최소값
  * 2. 오른쪽 부트리가 없는 경우, 어떤 노드 y의 외쪽 부트리의 최대값이 x가 되는 그런 노드
  * y가 x의 sucesssor, 부모를 따라 루트까지 올라가면서 처음으로 누군가의 왼쪽 자식이 되는 노드 
  * 3. y가 존재하지 않을경우 successor가 존재하지 않음 즉 x가 최대값
  * 
  *Predecessor
  *Successor과 대칭
  
  *이진검색트리의 insert
  *삽입할 때 이전노드들은 전혀 변경하지 않는다.
  *루트보다 작으면 왼쪽 크면 오른쪽에 삽입해준다.
  *포인터가 두개 필요하다. x,y x가 널이면 y가 가리키는 곳에 노드를 추가한다.
  *예외 루트가 널인경우 루트로 
  
  *이진검색트리의 DELETE
  *키를 삭제, 일단 탐색한후, 데이터가 일치하면 그노드 삭제
  *예외상황
  *1. 자식노드가 없는 경우 
     -데이터와 일치하는 노드 삭제하면된다. 부모의 노드를 널로 바꿔준다는 얘기다. (가장간단한케이스)
  *2. 자식노드가 1개인경우
     - 삭제노드의 부모도 유일 자식도 유일한경우로 트리이지만 연결리스트와 같다. 원래 부모가 나를 거쳐
     - 유일한 자식에게 가는건데 내가 삭제되는거니까 부모가 바로 자식에게 연결되면 된다.
  *3. 자식노드가 2개인경우
     - ex서브 트리의 노트를 삭제하는 경우 트리의 기본적 구조가 흐트러져서 복잡
     - 일종의 꼼수 노드 루트노드그대로 두고 저장된 데이터만 삭제하고 빈노드 둘 수 없음으로 다른 노드의 데이터를 가져옴
     - 누구를 대려올까 13대신 가져올 때 일이 간편해지는건 13에 가장 가까운 값 즉 successor
     - 아주 똑똑함 석세서란 얘기는 왼쪽에 있는 값들보다 크고 오른쪽에 있는 값들보다는 작다는 얘기다.
     - 또 왼쪽 자식노드가 없다는 얘기로 따라서 자식의 개수가 0개거나 1개 따라서 데이터를 옮기고 노드를 삭제하면 된다.
=========================================================================
 *2017-08-06
 *그래프
 *그간 한일, 안드로이드 복습 및, 깃에대한 공부
 
 *그래프 개념
 *
 *그래프 두개의 집합에의해 정의되는 구조 G = (V,E)
 *V는 정점 혹은 노드라고함
 *E 노드쌍을 연결하는 엣지 혹은 링크
 *개체들간의 이진관계를 표현하는 구조가 바로 그래프
 *보통 그래프라고하면 방향이 없는 그래프가 많고 방향이 없다는것은 그냥 이어져 있다는 뜻이다.
 *무방향은 즉 (1,2)와 (2,1)이 다른게 없다는 것 이다. 
 
 *방향그래프(Directed Graph) G =(V,E)
    에지 (u,v)는 u로부터 v로의 방향을 가졌다. 
 
 *가중치(weighted) 그래프
    각각 에지마다 가중치가 지정되어있다.
 
 *그래프의 표현
 *그래프가있을때 그래프를 어떤 자료구조로 표현하느냐 여러가지가 있지만 대부분 2가지 방법중 하나를사용한다.
   1. 인접행렬(adjacency matrix)
      -정점 개수가 n인 어떤그래프를 n*n 인 2차원 배열로 표현한 것이다. 
      -i번째행j번째 열의 값을 aij라고 한다면 i와j사이에 에지가 있으면 1 아니면 0으로 표현하는 것을 인접행렬이라고 한다.
      -인접행렬은 대칭행렬이다.
      -저장 공간 : O(n^2)
      -어떤 노드 v에 인접한 모든 노드 찾기 : O(n) 시간
          ex)3번 노드에 연결된걸 찾으려면 3행을 읽어봐야함 1이면 인접한거 
      -어떤 에지 (u,v)가 존재하는지 검사: O(1) 시간
          ex) u행 v열의 값이 1인지 0인지만 확인하면 된다. 


   2. 인접리스트(adjacency list)
      -정점이 5개인 그래프를 표현할때 먼저 길이가 5인배열만들어서 각각칸이 하나의 정점을 표현하게 한다.
      -그다음 각칸에 하나의 연결리스트( 실제로 정점에 인접한 정점의 번호)를 만들어 저장하는 방식이다.
      -노드의 개수는 2m개이다. 여기서 m은 edge의 개수를 말한다.
      -어떤 노드v에 인접한 모든 노드 찾기 O(degree(v))시간
          ex)연결리스트 길이에 비례 최악의경우 O(degree(n-1))외냐 모든 곳과 다 연결될 수 있음
          이 연산의 공우 인접행렬보다 더 좋음 왜냐면 인접행렬은 n이지만 리스트는 연결된 엣지만 찾아보면됨
      -어떤 에지 (u,v)가 존재하는지 검사 : O(degree(u))시간
          인접행렬에서는 3번과 5번이 연결되어있는지 알고싶으면 3,5하면 됐지만 여기서는 3번에 연결된 리스트를 다 살펴봐야한다.
          이점은 인접리스트가 더 불리함
    
    방향그래프라면?
       인접행렬은 더이상 대칭행렬이아니며 인접 리스트는 m개의 노드를 가진다. 

  * 가중치 그래프의 인접행렬 표현
    가중치 그래프를 인접행렬로 표현한다면? 
       1.생각 에지의 존재를 나타내는 값으로 1대신 에지의 가중치를 저장? 
            그럼 에지가 없을때는? 가중치가 0인경우는? 상황에 따라 올바른 방법 사용 
       2.에지가 없거나 대각선이라면?
           ex) 보통 가중치 그래프에서 가중치가 거리, 비용 이런걸 의미한다면 에지가 없다는 것은 비용이 무한대다 해석
           대각선, 자기자신부터 자기자신까지의 거리는 0(인접행렬에서 대각선)이다라고 볼 수 있음 

   * 그래프에서 사용하는 기본 용어
   *  경로 에지를 따라서 가는 경로 말그대로 길(path) 두노드를 연결하는 경로가있을때 서로 연결됐다고 말한다. 
   *  직접연결되있을 때는 인접(adjacent)이라고 하고, 연결은 거쳐서 갈 수 있다는 얘기다.
   *  어떤 그래프가있는데 모든 노드들이 서로 다 연결되어 있는 그래프를 연결된 그래프 connected graph라고 한다. 지금까지 한얘기는 무방향그래프 한정
   *  연결되어있는 각각의 덩어리들을 연결요소 (connected component)라고 말한다.
   *  
   
  