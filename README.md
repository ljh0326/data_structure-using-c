 * Practice Data_Structure Using C
 * 자료구조 복습
 * http://blog.naver.com/ljh0326s
 * 
=========================================================================
 * 2017-07-23 
 * 
 * linked-list.c
 * 
 * 알게된 점!!!!! 
 * strdup 문자열 받아서 주소값 반환
 * 헤드포인터는 항상 첫째노드 가리키고 있어야함 그래서 조회할때 새로운 포인터 생성
 * 노드를 삭제하기위해서는 그 전 노드를 알아야 한다. 그래서 새로운 노드를 만들어 따라가게 한다.
 *
=========================================================================
 *
 * 2017-07-24
 * 연결리스트 응용 다항식 
 * polynomial.c
 * 
 * 가정 
 * 1. 다항식의 이름은 x를 제외한 영문 소문자
 * 2. 변수는 항상 x이다.
 * 3. 각 항의 지수는 음이 아닌 정수이고, 계수는 정수이다.
 * 4. 항들이 반드시 차수에 대해 내림차순으로 입력되는 것은 아니며, 동일 차수의 항이 여럿 있을 수도 있다.
 * 5. =, +, - 등의 앞 뒤로 하나 이상의 공백이 있을수도, 없을 수도 있다.
 * 6. 함수는 항상 차수에 대한 내림차순으로 정렬되어 저장되고 출력된다.
 * 7. 동일 이름의 함수를 새로 정의할 수도있다. 이 경우 기존의 함수는 지워진다.
 * 
 * 알게된 점!!!
 * 동적으로 생성된 객체는 초기화가 필요하며 초기화 해주는 함수를 따로 만들어 사용하는 것도 좋은 방법이다.
 * 
 * 아직진행중
 * 
=========================================================================
 * 2017-07-25
 * 연결리스트 응용 다항식 - 완성 디버깅필요
 * 
 * 이중연결리스트
 * 이중연결리스트는 tail필요 -> 마지막 노드 가리킴
 * tail없어도 되지만 그럴꺼면 이중리스트 왜씀? 이중연결리스트를 쓰는 이유 중 하나는 뒤에서부터 앞으로도 갈려고하는 것
 * 
 * 노드 삽입
 * 1. 뉴노드 생성
 * 2. 뉴노드의 next = p
 * 3. 뉴노드의 prev = p -> prev
 * 3. p -> prev -> next = new_node;
 * 4. p -> prev = new_node
 * 
 * 노드 삭제
 * 1. p -> prev -> next = p -> next
 * 2. p -> next -> prev = p -> prev
 * 
 * ---------------------------------------------
 * 시간복잡도와 점근적 분석
 * 
 * 알게된 것!
 * 
 * 좋은 프로그램은?
 * 1.빠른거, 잘 구조화되어있고, 모듈화되어있어서 개선 기능 추가 재사용하기 용이한가, 호완성, 디자인
 * 2. 알고리즘의 자원 사용량 분석(객관적)
 *   2-1. 자원의 종류 : 시간, 메모리, 저장장치, 통신(패킷)
 * 여기서는 실행시간 분석에 대해서만 다룬다.
 
 
 *시간분석?
 *사실 실행 속도는 실행환격에 따라 달라지기 때문에 시간복잡도가 1초다 이런식으로 얘기할 수 없다.
 *그래서 일반적으로 연산의 실행 횟수를 카운트하는 것으로 시간복잡도를 측정한다. 항상이런건 아님
 *그런데 생각해보면 데이터에 따라 비교연산 횟수 달라짐 그래서 입력 데이터의 크기에 대한 함수로 표현한다.
 *그런데 데이터가 같더라도 실제 데이터에 따라 달라질 수 있음(입력 데이터가 같다고 실제 연산이 같지는 않다.)
 *그럼? 다다르다면 그냥 대표값을 이용해서 표현하는게 방법중 하나가 될 것
 *가장 대표적인 대표값 = 평균 
 *그리고 또다른 대표값이 최악의 경우( 다다른데 최악은뭐냐, 탐색에서 데이터가 마지막에 있거나 없는경우) 그럼n번 비교해야지.
 *그런데 평균시간복잡도 분석 어려움 그래서 보통은 최악의 경우 시간복잡도 사용한다.

 * 점근적 분석
 * 실행횟수 카운트할때 정확하게 분석하는게아니라 n*(n-1) + 5 가있다면 n에관한 2차함수기때문에
 * O(n^2)라고 표시함 즉 연산의 최고차항만 남기는거야 보통 빅O라고 읽기도함
 
=========================================================================
  *2017-07-26
  *순환(Recursion)
  *Recursion.java
  *자기 자신을 호출하는 함수 
  *적절한 구조를 갖춰야 무한루프에 빠지지 않는다.
  *
  * 구조의 조건 
  *   1.적어도 하나의 recursion에 빠지지 않는 조건이 존재해야한다.(Bace case라고 부른다.)
  *   2.Recursive case를 통해 반복하다보면 base case에 수렴하게 해야 한다.
  * 
  * 해석 예제
  * public static int func(int n){
      n == 0 ? return 0 : return n + func(n-1);
  }
  * 이 함수의 mission은 0~m까지의 합을 구하는 것이다.
  * n = 0 dlaus gkqdms 0 dlek.
  * n이 0보다 크다면 0에서 n까지의 합은 0에서 n-1까지 합에 n을 더한것이다.
  * 
  ----------------------------------------

  * 순환적으로 사고하기(Recursion Tginking)
  * 반복문으로 해결할수 있는 문제들을 Recursion으로 풀어보자
  * Recursion2.java
  *
1. 문자열 길이계산 길이하나하나 세는게 정석
  *     Recursive로 생각하면 문자열의 길이는 첫번째를 제외한 문자열의 길이 + 1
  * 2. 문자열의 프린트
  *     첫번째 문자를 출력한 후 Recursive로 첫번째 문자를 제외하고 출력한다.
  * 3. 문자열 뒤집어서 프린트
  *     Recursive로 첫번째 글자를 제외하고 프린트 후 첫번째 문자를 출력한다.
  * 4. 배열에있는 숫자 더하기
  *     Recursive로 마지막 데이터 전까지 모두 더한 후 마지막 문자를 더해준다.
  * 5. 파일출력
  *     Recursive로 마지막 데이터 전까지 모두 출력한 후 마지막 문자를 출력한다.
  *     
  * 모든 순환한수는 반복문으로 변경가능하며 그 역도 성립한다.
  * 순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 하지만
  * 함수 호출에 따른 오버해드가 있다.
  * 
=========================================================================
  *2017-07-27
  *순환(Recursion)3
  *Designing Recursion 순환 설계 하는 방법 및 노하우
  
  *1. 구조가 복잡할수록 기본을 잊지말자
      1-1 적어도 하나의 base case, 즉 순횐되지 않고 종료되는 case가 있어야하고 모든
          case는 결국 base case로 수렴해야 한다.
  
  *2. Recursion으로 프로그래밍 할 때에는 암시적 매개변수를 명시적으로 바꿔주어야 한다.]
      ex) 순차탐색, 첫번째값이 내가 찾는거라면 즉시 반환 아니라면 나머지 타켓을 검색하면된다.
=========================================================================
 *2017-07-28
 *순환 (Recursion)응용 미로탈출
    Maze.java
 *미로찾기 문제를 해결하는 방법은 많으나 순환으로 해결하는게 가장 명확하다.
 *How? Recursive
    - 현제 내가 위치에서 출구까지 가는 경로가 있으려면
    - 1. 현재 위치가 출구거나
    - 2이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가는 경로가 있꺼나
 *일단 Decision problem 문제로 생각해보자
    큰틀
    - 출구면 return true 
    - 출구가 아니고 주위 각 셀(최대4개)이 통로라면 다시 findPath 만약 출구를 찾으면 true 아니면false
 *
    세부내용
    - 내가 방문한 부분과 아닌 부분을 기억해야함 즉 위 큰틀에서 마크를 먼저하고 큰 틀내용을 진행하면 된다.
  
 * 응용2 Counting cells in a Block
 * 문제 : 바이너리 이미지가 주어지면 각 셀이 픽셀에 해당되고 각각 픽셀은 
 * 백그라운드 픽셀이거나 이미지 픽셀(흑백사진) blob는 서로 연결된 이미지 집합
 * 상하좌우 및 대각방향으로도 연결된 것으로 간주
 * 
 *Recursion Thinking
 *현재 픽셀이 속한 blob를 카운트하려면
    1.현재 픽셀이 image픽셀이 아니라면 0 반환
    2.현재 픽셀이 image픽셀이라면 현재픽셀을 카운트한 후
    3.중복 카운트 방지를 위해 다른 색으로 칠하고
    4.현재 픽셀에 이웃한 모든 픽셀들에 대하여 그 픽셀이 속한 blob의 크기를  카운트하여 더해준다. return counter
  
 *응용3 N-queen
   다시공부
-----------------------------------------------------------------
  *트리(Tree)
  *기본용어 노드 레벨, 자식 부모 자손 조상
  *노드가N개인 트리는 항상 N-1개의 링크를 가진다.

  * 이진트리
  * 각각의 노드는 최대 2개의 자식을 갖는다.
  * 자식 노드는 자신의 부모의 왼쪽 자식이지 오른쪽 자식인지가 지정되며 오른쪽 왼쪽이 다르면 서로 다른 노드이다.
  * 이진트리 응용 예 :Expression Tree ,허프만 코드(파일 압축)
  * FUll binary tree 모든 노드가 꽉찬 트리 , complete binary tree 노드가 몇개 비어있지만 왼쪽부터 비어있는 트리
  * full binary tree인 경우 높이가 h면 tree는 2^h-1개의 노드를 갖는다
  * 노드가 N개인 이진트리의 높이는 최악의 경우 N이 된다. 
  * 
  *이진트리 순회(traversal)
  *이진트리 모든 노드 방문 연결리스트는 순서대로 방문하면됨
  *트리는 선형적 구조가아니라 연결리스트 모든 노드 방문할때 다양한 방문이 있을 수 있음
     1. 중순위(inorder)순회
        -먼저 트리부분을 3부분으로 나눠서 생각 가장먼저 루트, 왼쪽 오른쪽 이렇게 
        -왼쪽을 inorder로 순회하고, r을 순회하고, 오른쪽을 inorder로 순회하는데 이말은 recursive함을 얘기한다.
     2. 선순위(preorder)순회
         -노드를 먼저 출력 후 외쪽 트리 오른쪽 트리 출력
     3. 후순위(postorder)tnsghl
         -왼쪽트리 출력 오른쪽 트리 출력 노드 출력 순서
     4. 그외 레벨오더(level-order) 순회
         -레벨 순서대로 출력, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 출력
         -큐를 이용하여 구현
  * 중순위 선순위 후순위는 아주 유사하다 
  * 
  ----------------------------------------------------------
  * 이진검색 트리
  * 검색트리? 트리는 계층구조를 표현하지만, 검색트리는 일종의 그냥 컨테이너 즉 일종의 집합
  * Dynamic Set이라고도 부르는데 여러게의 데이터가 다이나믹하다는 의미다.(데이터가 고정된것이아니라 추가되거나 삭제될 수도있다)
  * 키에대해 새로운 키를 추가하거나 삭제하거나 탐색하거나 하는 3가지 연산을 효율적으로 지원하기 위한 자료구조
  * 
  * 정렬된 혹은 정렬되지 않은 배열 혹은 연결리스트를 사용할 경우INSERT, SEARCH, DELETE중 하나는 O(N)이걸 해결하고자함
  * 해결 하는 방법중 하나가 트리, 그리고 다른방법이 해쉬테이블이다.
  * 
  * 이진검색트리(BST Binary Search Tree)에 대해 살펴보자
  *  1. 이진트리 각각노드가 2개씩이고 누가 왼쪽자식이고 오른쪽자식인지 명시되어있다.
  *  2. 각노드마다 하나의 데이터가 저장
  *  3. 각노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고 오른쪽 부트리에 있는 값은 크거나 같다.
  *  4. 트리의 모양에 특정 제약이없고 바이너리 트리기만 하면 된다. 
  *  
  *  Search 특정한 값 있는지 없는지 위치 찾는거 
  *  
  --------------------------------------------------------------
  *이진검색트리 최솟값 찾기
  * 알고리즘 left[x] 가 널이 될때까지 왼쪽으로 따라 내려가라 시간복잡도 O(h)
  * 
  * Successor (다음값)
  * 나보다 크면서 가장 작은 값 (모든키들이 서로 다르ㄱ다고 가정 15의 석세서는 16)
  * 석세서 구하는 방법 3가지경우
  * 1. 노드x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최소값
  * 2. 오른쪽 부트리가 없는 경우, 어떤 노드 y의 외쪽 부트리의 최대값이 x가 되는 그런 노드
  * y가 x의 sucesssor, 부모를 따라 루트까지 올라가면서 처음으로 누군가의 왼쪽 자식이 되는 노드 
  * 3. y가 존재하지 않을경우 successor가 존재하지 않음 즉 x가 최대값
  * 
  *Predecessor
  *Successor과 대칭
  
  *이진검색트리의 insert
  *삽입할 때 이전노드들은 전혀 변경하지 않는다.
  *루트보다 작으면 왼쪽 크면 오른쪽에 삽입해준다.
  *포인터가 두개 필요하다. x,y x가 널이면 y가 가리키는 곳에 노드를 추가한다.
  *예외 루트가 널인경우 루트로 
  
  *이진검색트리의 DELETE
  *키를 삭제, 일단 탐색한후, 데이터가 일치하면 그노드 삭제
  *예외상황
  *1. 자식노드가 없는 경우 
     -데이터와 일치하는 노드 삭제하면된다. 부모의 노드를 널로 바꿔준다는 얘기다. (가장간단한케이스)
  *2. 자식노드가 1개인경우
     - 삭제노드의 부모도 유일 자식도 유일한경우로 트리이지만 연결리스트와 같다. 원래 부모가 나를 거쳐
     - 유일한 자식에게 가는건데 내가 삭제되는거니까 부모가 바로 자식에게 연결되면 된다.
  *3. 자식노드가 2개인경우
     - ex서브 트리의 노트를 삭제하는 경우 트리의 기본적 구조가 흐트러져서 복잡
     - 일종의 꼼수 노드 루트노드그대로 두고 저장된 데이터만 삭제하고 빈노드 둘 수 없음으로 다른 노드의 데이터를 가져옴
     - 누구를 대려올까 13대신 가져올 때 일이 간편해지는건 13에 가장 가까운 값 즉 successor
     - 아주 똑똑함 석세서란 얘기는 왼쪽에 있는 값들보다 크고 오른쪽에 있는 값들보다는 작다는 얘기다.
     - 또 왼쪽 자식노드가 없다는 얘기로 따라서 자식의 개수가 0개거나 1개 따라서 데이터를 옮기고 노드를 삭제하면 된다.
=========================================================================
 *2017-08-06
 *그래프
 *그간 한일, 안드로이드 복습 및, 깃에대한 공부
 
 *그래프 개념
 *
 *그래프 두개의 집합에의해 정의되는 구조 G = (V,E)
 *V는 정점 혹은 노드라고함
 *E 노드쌍을 연결하는 엣지 혹은 링크
 *개체들간의 이진관계를 표현하는 구조가 바로 그래프
 *보통 그래프라고하면 방향이 없는 그래프가 많고 방향이 없다는것은 그냥 이어져 있다는 뜻이다.
 *무방향은 즉 (1,2)와 (2,1)이 다른게 없다는 것 이다. 
 
 *방향그래프(Directed Graph) G =(V,E)
    에지 (u,v)는 u로부터 v로의 방향을 가졌다. 
 
 *가중치(weighted) 그래프
    각각 에지마다 가중치가 지정되어있다.
 
 *그래프의 표현
 *그래프가있을때 그래프를 어떤 자료구조로 표현하느냐 여러가지가 있지만 대부분 2가지 방법중 하나를사용한다.
   1. 인접행렬(adjacency matrix)
      -정점 개수가 n인 어떤그래프를 n*n 인 2차원 배열로 표현한 것이다. 
      -i번째행j번째 열의 값을 aij라고 한다면 i와j사이에 에지가 있으면 1 아니면 0으로 표현하는 것을 인접행렬이라고 한다.
      -인접행렬은 대칭행렬이다.
      -저장 공간 : O(n^2)
      -어떤 노드 v에 인접한 모든 노드 찾기 : O(n) 시간
          ex)3번 노드에 연결된걸 찾으려면 3행을 읽어봐야함 1이면 인접한거 
      -어떤 에지 (u,v)가 존재하는지 검사: O(1) 시간
          ex) u행 v열의 값이 1인지 0인지만 확인하면 된다. 


   2. 인접리스트(adjacency list)
      -정점이 5개인 그래프를 표현할때 먼저 길이가 5인배열만들어서 각각칸이 하나의 정점을 표현하게 한다.
      -그다음 각칸에 하나의 연결리스트( 실제로 정점에 인접한 정점의 번호)를 만들어 저장하는 방식이다.
      -노드의 개수는 2m개이다. 여기서 m은 edge의 개수를 말한다.
      -어떤 노드v에 인접한 모든 노드 찾기 O(degree(v))시간
          ex)연결리스트 길이에 비례 최악의경우 O(degree(n-1))외냐 모든 곳과 다 연결될 수 있음
          이 연산의 공우 인접행렬보다 더 좋음 왜냐면 인접행렬은 n이지만 리스트는 연결된 엣지만 찾아보면됨
      -어떤 에지 (u,v)가 존재하는지 검사 : O(degree(u))시간
          인접행렬에서는 3번과 5번이 연결되어있는지 알고싶으면 3,5하면 됐지만 여기서는 3번에 연결된 리스트를 다 살펴봐야한다.
          이점은 인접리스트가 더 불리함
    
    방향그래프라면?
       인접행렬은 더이상 대칭행렬이아니며 인접 리스트는 m개의 노드를 가진다. 

  * 가중치 그래프의 인접행렬 표현
    가중치 그래프를 인접행렬로 표현한다면? 
       1.생각 에지의 존재를 나타내는 값으로 1대신 에지의 가중치를 저장? 
            그럼 에지가 없을때는? 가중치가 0인경우는? 상황에 따라 올바른 방법 사용 
       2.에지가 없거나 대각선이라면?
           ex) 보통 가중치 그래프에서 가중치가 거리, 비용 이런걸 의미한다면 에지가 없다는 것은 비용이 무한대다 해석
           대각선, 자기자신부터 자기자신까지의 거리는 0(인접행렬에서 대각선)이다라고 볼 수 있음 

   * 그래프에서 사용하는 기본 용어
   *  경로 에지를 따라서 가는 경로 말그대로 길(path) 두노드를 연결하는 경로가있을때 서로 연결됐다고 말한다. 
   *  직접연결되있을 때는 인접(adjacent)이라고 하고, 연결은 거쳐서 갈 수 있다는 얘기다.
   *  어떤 그래프가있는데 모든 노드들이 서로 다 연결되어 있는 그래프를 연결된 그래프 connected graph라고 한다. 지금까지 한얘기는 무방향그래프 한정
   *  연결되어있는 각각의 덩어리들을 연결요소 (connected component)라고 말한다.
   *  
   --------------------------------------------------------------
     그래프 순회 (Graph Traversal)
       순회(traversal)
           그래프의 모든 노드들을 방문하는 일
       대표적 두 가지 방법
           BFS (Breadth - First Search, 너비 우선 순회)
           DFS (Depth-First Search, 깊이 우선 순회)

   * BFS 
   * 그래프에서 노드들을 동심원의 형태로 순회하는 알고리즘 일단 모든 그래프를 방문하기 위해서는 출발노드가 주어져야 한다.
   * 먼저 출발노드(s)를 하나를 방문하고 s와 인접한 노드들을(s로부터 거리가 1인노드들) 그다음은 s로부터 거리가 2인노드들
   * 즉 s로부터 거리가 1인노드들과 직접 연결된 노드들 방문하고, s로부터 2칸떨어진거 방문했으면 3칸떨어진 노드들 이런식으로 방문하는 것
   * 말그대로 동심원의 형태로 퍼져나가는 이런 순서로 노드를 방문하는것을 너비우선순회라고 한다 점점 넓어진다. 이런 얘기
   * 다르게 말하자면 BFS에서 출발점을 L0라고 하고 방문한 후 L1을 방문하는데 L1은 L0의 모든 이웃노드들을 말한다.
   * 그다음은 L2에속한 L2는 L1에속한 노드의 이웃노드들중 L0를 제외한 노드를 말한다. 
   * 
   * 문제는 이 과정을 어떻게 코드로 구현할 것인가다
   * 일반적으로 BFS를 구현하는 가장 간단한 방법은 큐를 사용한다. 
   * 
   * 진행과정
   * 1. check the start node;
   * 2. insert the start node into the queue;
   * 3. 와일문 돌면서 큐가 빌때까지 q에서 노드를 하나 꺼내고 큐에서 꺼낸 노드의 인접한 노드중에서 unchek(방문하지않은)
   *    모든 이웃노드들에대해 체크하고 큐에 다시 넣는다. 
   * 4. 계속 반복 다시 들어가있는 노드를 하나 꺼내서 꺼낸 노드에 인접한 노드를 체크 후 큐에 넣는다. 
   * 5. 큐가 비면 종료가된다. 
   * 순서는 유일하지 않다. 프로그램에따라 동일너비는 누구든 먼저 들어갈 수 있다.
   * 
   * BFS는 단순히 모든 노드들을 방문하는 것 외에 중요한 일을 할 수 있다.
   * 바로 그것이 최단경로, 여기서 경로의 길이는 경로에 속한 에지의 개수를 의미한다. 
   * 즉 BFS는 각각의 노드까지 가장 짧은 경로를 구할 수 있다. 
   * 만약 어떤 노드가 L1에 속해있다면 출발점에서부터 어떤노드까지 가장 짧은경로는 1이다. 
   * 어떤노드가 L2에속한다면 경로는 2이다.
   * 
   * 우리는 앞으로 d[v]와 π[v]를 구할건데 
   * d[v] = s 로부터 v까지의 최단 경로의 길이(에지의 개수)
   * π[v] = s로부터 v까지의 최단경로상에서 v의 직전 노드(predecessor)을 의미한다.
   * 시간복잡도는 O(n+m) n은 모든 노드들에 대해 d값과 π 값을 for문을 통해 초기화해야하기 때문이다.
   * while문은 queue가 빌때까지 도는데 몇번돈다 하기 어렵지만 잘 생각해보면 체크가 안된노드만 큐에 넣음
   * 결국 어떤 노드도 큐에 2번들어가지는 않는다. 그러니까 while문은 결국 n번돈다. 그런데 다시 안에 for문이 숨어있어서
   * 중첩 루프임, 인접 행렬이냐 인접리스트냐에따라 시간복잡도 달라짐, 인접행렬이라면 O(n^2), 인접리스트라면O(n+m)
   * 그래프에서 에지개수가 많지않다면 인접리스트로 표현하는것이 좀 더 효율적이다.
   * 
   * 파이값을 이용해서 각각의 노드를 자신의 v와 predecessor를 연결하면 하나의 트리가 만들어지는데 그 트리를 보통
   * BFS 트리라고 한다. BFS 트리에서 s에서 v까지의 경로는 s에서 v까지 가는 최단 경로가 되고 
   * 중요한 한가지 특징은 이 트리상의 어떠 ㄴ에지도 2개의 layer를 건너가지 않는다. 
   * 
   * 최단경로 실제로 출력하기
   * 모든노드에대해  π[v]를 계산했다 가정하고  π[v]를 이용해 s에서 v까지 출력해주는 알고리즘
   * 만약 v가 출발점(s)이라면 그냥 s출력
   * π[v] ==NULL이라면 두가지경우 v가 s거나, 실제로 s에서 v까지 가는 최단경로가 존재하지 않느다는 것, 걍 경로가 없다는 거다.
   * 위와 같은경우는 그냥 경로가 존재하지 않는다 출력하면되고 
   * 그러지 않다면 일반적인경우 일반적인 경우 간단한 recursion으로 처리할 수 있다.
   * s에서 v까지가는 최단경로를 출력하는건데 v의 직전노드가 π[v] 니까 s에서 v까지가는 최단경로는
   * 먼저 s에서 π[v]까지 가는 최단경로를 출력하고 그다음에 v를 추가로 출력해주면 된다. 
   * 
   * BFS가 connected라면 모든노드를 방문하지만 disconnected이거나 방향그래프라면 모든 노드가 방문되지 않을 수 있다.
   * 이때 모든노드를 방문하는것이 목적이라면 이때는 BFS를 한번만해서는 안되고 여러번 반복해서 모든 노드를 방문해야한다.
   * while (unvisited인 노드가있다면 그 노드를 출발점으로 BFS를 하면 된다. )
   * 
   *
   *DFS(깊이 우선순회)
   *이진탐색트리의 순회방법 3가지 종류는 사실 DFS의 이진트리버전인데 좀더 세분해서 3가지 방법으로 나눴다고 생각하면된다.
   *일반적으로 그래프에서 깊이우선탐색은 출발점이 주어지고 시작한 부분에서, 출발점을 check해주고
   *인접한 노드중에 방문되지 않은 노드있으면 그중 하나 선택해서 check하고 다시 그 노드에 인접한 노드중 아직
   *방문하지 않은 노드가 있다면 그노드 체크하고 이런식으로 인접한 노드중 아직 안가본 노드가 있다면 계속 가는 것
   *그러다 인접한 노드들이 check되어있다면 좀전에 있던 위치로 되돌아와서 안가본 노드 있는지 보고 있으면가고 없으면 계속 돌아감
   *마지막으로 s로 돌아오고 더이상 갈곳이 없다면 종료
   
   *DFS 알고리즘 구현 이진 트리에서 순회를 구현한것처럼 DFS를 구현하는 가장 간단한 방법은 recursion을 사용하는 것이다.
   *어떤 v노드에 도착을하면 체크를 하고 인접한 각각의 노드 u에 대해서 만약 u가 방문되지 않았다면 DFS(G, u)
   *인접한 노드가 하나도 없다면 함수가 종료되고, recursion이기 때문에 이함수를 호출한곳으로 돌아감
   *BFS처럼 만약 disconnected라면 한번의 DFS만으로 모든 노드를 방문할 수 없다.
   *시간 복잡도 O(n + m) n은 초기화 m은 에지 하나당 한번의 recursion소환되기 때문에 2m이라고 생각하면된다.
   *인접 행렬로 그래프를 표현했다면 시간복잡도는 O(n^2)된다. 
---------------------------------------------------------------------
   DAG(방향그래프 Directed Acyclic Graph)
   *무방향그래프에비해 얘기가 복잡함, 1 -> 2로갈수있다고 2에서 1로 갈수있는게 아님 
   *결과에만 차이가 있을 뿐 알고리즘에는 차이가 없다. 
   *
   * DAG는 방향 사이클이 없는 방향그래프를 말한다.
   * 매우 중요한 용도들이있는데 일반적으로 작업들의 우선순위를 표현할 때 사용한다.
   * 어떤작업이 반드시 다른작업이 선행되어야할때 그 작업과 다른작업간을 화살표로 연결한다. 
        ex) b -> c로가는 에지가 있다는것은 c로가기전 반드시 b를 해야한다는 얘기다.
 
   *위상정렬(topological ordering)
     어떤 순서로 작업을 해야할까 즉 dag에 이쓴 모든 노드들을 ordering하는데 이 작업을 하기위해서는 어떤조건을
     만족해야 할까? 모든 에지는 오른쪽 방향이어야한다. 역방향이 있다면 안됨
    그래서 위상정렬이란 것은 dag의 노드들을 순서화 한다는 얘기다.
   *일반적으로 위상정렬은 답이 유일하지 않다. 

   * 위상정렬 알고리즘
     1. 일반적으로 방향그래프에서 어떤노드로 들어오는 에지와 나가는 에지로 구분하는데 
        들어오는 에지를 incoming edge 나가는 에지를 outgoing edge라고 부르고 
        들어오는 에지의 개수를 indgree라고 부르고 나가는 에지의 개수를 outdgree라고 한다.
        일단 indgree가 0인것을 찾는다. indgree가 0이면 선행작업이 없다는 얘기다.
        가장 먼저 나와도 된다는 얘기 a에서 나가는 엣지들은 생각할 필요가 없다. 
        노드 a와 a에서 나가는 edge를 그래프에서 제거해준다. 
     2. 남은 그래프에서 다시 indgree가 0인 노드를 찾아서 출력을하고 해당 노드와 edge를 제거해준다.
     
     다시한번더 
       1. 진입간선이 없는 임의의 정점u를 선택한 후 u를 출력하고 
       2. 정점 u와 u의 진출간선을 모두 제거한다. 다시 돌아가서 진입간선이 없는 임의의 정점을 택해서 반복
       
     이 알고리즘 할 얘기가 있음
       1. indgree가 0인 노드가 존재하지 않으면?
       2. indgree 0인 노드 어떻게 찾을래? 
       3. 정점과 outgoing을 어떻게 제거할거냐.(구현)
      
      
    *위상정렬 알고리즘2
      1. R이라는 empty linked list를 만든 다음에 정점의 순서상관없이
      2. visited 되지 않은 임의의노드 아무거나 잡아서 DFS-TS를 하면 된다.
      3. DFS-TS는? 노드를 먼저 visited체크하고 인접한 각각의 노드x에대해 만약 그 x가 unvisited라면 
         x에 대해 다시 DFS 여기까지는 그냥 DFS 마지막에 한줄 추가되어있음 
         언제 이 마지막코드 도착하지? 어떤 방향으로 갈수있는데까지 다 가보고 더이상 갈때가 없어서 전노드로 되돌아가야하는시점
         이때 원래 DFS에서는 그냥 되돌아갔지만 여기서는 이 노드를 내가만든 연결리스트 R에 프론트에 node를 추가시켜준다.
